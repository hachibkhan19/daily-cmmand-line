## ডেকোরেটর আসলে একটি ফাংশন, যা ব্যবহার করে আমরা একটি ফাংশন বা ক্লাসের কার্যক্ষমতা পরিবর্তন বা সম্প্রসারণ করতে পারি, তবে মূল ফাংশন বা ক্লাসটি পরিবর্তন না করেই। এটি মূলত এক ফাংশনকে আরেক ফাংশনের উপর "লেপ" দেয়ার মতো কাজ করে।
## ডেকোরেটর ব্যবহারের সুবিধা:
1. কোড পুনঃব্যবহারযোগ্যতা (Reusability): একবার ডেকোরেটর লিখলে, সেটি বহু জায়গায় ব্যবহার করা যায়।
2. কোড পরিষ্কার ও সংক্ষিপ্ত রাখা (Code Clarity): ডেকোরেটরের সাহায্যে কোড ছোট ও সহজে পড়ার মতো করা যায়।
3. ফাংশনের চারপাশে অতিরিক্ত লজিক যোগ করা (Extending Functionality): ফাংশনের আগে বা পরে কোনো কাজ করতে চাইলে ডেকোরেটর ব্যবহার করা যায়।
## কিভাবে ডেকোরেটর কাজ করে?

### উদাহরণ ১: সহজ ডেকোরেটর
```
  def my_decorator(func):
    def wrapper():
        print("ফাংশনের আগে কিছু কাজ করছি...")
        func()
        print("ফাংশনের পরে কিছু কাজ করছি...")
    return wrapper

@my_decorator
def say_hello():
    print("হ্যালো, পাইথন!")

say_hello()

```
## আউটপুট:

```
  রাহিম এর জন্য ফাংশনের আগে কিছু কাজ করছি...
  স্বাগতম, রাহিম!
  রাহিম এর জন্য ফাংশনের পরে কিছু কাজ করছি...

```

## এই উদাহরণে, মূল ফাংশনটি (core function) হলো:
  ```
    def say_hello():
    print("হ্যালো, পাইথন!")
  ```

  কেন এটি মূল ফাংশন (core function):
1. মূল কাজ:
 * say_hello ফাংশনটির কাজ হলো "হ্যালো, পাইথন!" প্রিন্ট করা।
 * এটি একটি সাধারণ ফাংশন, যা ডেকোরেটর ছাড়াও আলাদাভাবে কাজ করতে পারে।

2. ডেকোরেটর প্রয়োগের আগে:
  * আপনি সরাসরি say_hello() কল করলে শুধুমাত্র "হ্যালো, পাইথন!" প্রিন্ট হবে।
  * ডেকোরেটরের কাজ হলো এই ফাংশনের কার্যকারিতা (functionality) বাড়ানো।

3. ফাংশন পরিবর্তনের প্রয়োজন নেই:

 * say_hello ফাংশনটি পরিবর্তন ছাড়াই ডেকোরেটরের মাধ্যমে অতিরিক্ত কার্যক্ষমতা পেয়েছে।
 * ডেকোরেটরের লজিক সরাসরি say_hello ফাংশনে যোগ করা হয়নি, বরং ডেকোরেটর @my_decorator এই কাজটি করছে।


