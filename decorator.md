## ডেকোরেটর আসলে একটি ফাংশন, যা ব্যবহার করে আমরা একটি ফাংশন বা ক্লাসের কার্যক্ষমতা পরিবর্তন বা সম্প্রসারণ করতে পারি, তবে মূল ফাংশন বা ক্লাসটি পরিবর্তন না করেই। এটি মূলত এক ফাংশনকে আরেক ফাংশনের উপর "লেপ" দেয়ার মতো কাজ করে।
## ডেকোরেটর ব্যবহারের সুবিধা:
1. কোড পুনঃব্যবহারযোগ্যতা (Reusability): একবার ডেকোরেটর লিখলে, সেটি বহু জায়গায় ব্যবহার করা যায়।
2. কোড পরিষ্কার ও সংক্ষিপ্ত রাখা (Code Clarity): ডেকোরেটরের সাহায্যে কোড ছোট ও সহজে পড়ার মতো করা যায়।
3. ফাংশনের চারপাশে অতিরিক্ত লজিক যোগ করা (Extending Functionality): ফাংশনের আগে বা পরে কোনো কাজ করতে চাইলে ডেকোরেটর ব্যবহার করা যায়।
## কিভাবে ডেকোরেটর কাজ করে?

### উদাহরণ ১: সহজ ডেকোরেটর
```
  def my_decorator(func):
    def wrapper():
        print("ফাংশনের আগে কিছু কাজ করছি...")
        func()
        print("ফাংশনের পরে কিছু কাজ করছি...")
    return wrapper

@my_decorator
def say_hello():
    print("হ্যালো, পাইথন!")

say_hello()

```
## আউটপুট:

```
  রাহিম এর জন্য ফাংশনের আগে কিছু কাজ করছি...
  স্বাগতম, রাহিম!
  রাহিম এর জন্য ফাংশনের পরে কিছু কাজ করছি...

```

## এই উদাহরণে, মূল ফাংশনটি (core function) হলো:
  ```
    def say_hello():
    print("হ্যালো, পাইথন!")
  ```

  কেন এটি মূল ফাংশন (core function):
1. মূল কাজ:
 * say_hello ফাংশনটির কাজ হলো "হ্যালো, পাইথন!" প্রিন্ট করা।
 * এটি একটি সাধারণ ফাংশন, যা ডেকোরেটর ছাড়াও আলাদাভাবে কাজ করতে পারে।

2. ডেকোরেটর প্রয়োগের আগে:
  * আপনি সরাসরি say_hello() কল করলে শুধুমাত্র "হ্যালো, পাইথন!" প্রিন্ট হবে।
  * ডেকোরেটরের কাজ হলো এই ফাংশনের কার্যকারিতা (functionality) বাড়ানো।

3. ফাংশন পরিবর্তনের প্রয়োজন নেই:

 * say_hello ফাংশনটি পরিবর্তন ছাড়াই ডেকোরেটরের মাধ্যমে অতিরিক্ত কার্যক্ষমতা পেয়েছে।
 * ডেকোরেটরের লজিক সরাসরি say_hello ফাংশনে যোগ করা হয়নি, বরং ডেকোরেটর @my_decorator এই কাজটি করছে।

## উদাহরণ 2
  ```
    def smart_div(fun):
    def inner(a, b):
        if a < b:
            a, b = b, a  # যদি a ছোট হয় b এর চেয়ে, তাহলে তাদের অদল-বদল করা হবে।
        return fun(a, b)  # মূল ফাংশন `fun` কল করা হচ্ছে।
    return inner

    @smart_div
    def div(a, b):
        return a / b  # দুটি সংখ্যার ভাগফল রিটার্ন করা হচ্ছে।
    
    print(div(2, 4))

  ```
## কোডের আউটপুট:
  ```
    2.0
  ```
## কোড কীভাবে কাজ করছে?

1. smart_div ডেকোরেটর:

 * এটি মূল ফাংশন div এর চারপাশে একটি লজিক যোগ করে।
 * যদি a ছোট হয় b এর চেয়ে, তাহলে তারা অদল-বদল (swap) হয়ে যায়।
 * এর ফলে, সব সময় বড় সংখ্যা a হয় এবং ছোট সংখ্যা b হয়।
   
2. @smart_div এর মাধ্যমে:

 * div ফাংশন smart_div ডেকোরেটরের মাধ্যমে "লেপানো" হয়েছে।
 * যখন div(2, 4) কল করা হয়, তখন প্রথমে smart_div এর inner ফাংশন কাজ করে।
 * inner ফাংশন নিশ্চিত করে যে a বড় এবং b ছোট, তারপর মূল div ফাংশনকে কল করে।
   
3. উদাহরণ:

 * div(2, 4) কল করলে:
* a = 2, b = 4
* inner ফাংশন চেক করে যে a < b, তাই তারা অদল-বদল হয়। এখন a = 4 এবং b = 2।
* মূল div ফাংশন কল হয়: 4 / 2 = 2.0

