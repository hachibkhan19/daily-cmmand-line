#### How to create a branch
```
git branch (branch_name)
```
#### How to delete a branch. Before deleting a branch, make sure you are not on the branch you want to delete. You can switch to a different branch using the git checkout command.
```
git branch -d (branch_name)
```
#### To create a new branch and switch to it
```
git checkout -b new_branch_name
```
### How to clone code from a specific branch from remote repo
 ```
  git clone -b dev git@git.inneedcloud.com.bd:InNeed/Quantlio_Stratus.git
  or
  git clone -b dev https://git.inneedcloud.com.bd/InNeed/Quantlio_Stratus.git

 ```
### git config pull.rebase false
 * যখন আপনি git config pull.rebase false সেটিং ব্যবহার করেন, তখন git pull করার সময় যদি আপনার লোকাল ব্রাঞ্চে কিছু পরিবর্তন থাকে এবং রিমোট ব্রাঞ্চেও কিছু পরিবর্তন থাকে, তাহলে Git আপনার লোকাল ব্রাঞ্চে রিমোট ব্রাঞ্চের পরিবর্তনগুলোর    সঙ্গে মার্জ (merge) করবে।

1. এটি এমন একটি প্রক্রিয়া, যেখানে:
   * আপনার লোকাল ব্রাঞ্চে যেসব কমিট করা হয়েছে তা রিমোট ব্রাঞ্চের পরিবর্তনের সাথে একত্রিত হয়।
   * যদি দুটি ব্রাঞ্চের মধ্যে কোনো কনফ্লিক্ট না থাকে, তবে Git সাধারণত মার্জ কমিট তৈরি করে, যা দুইটি ব্রাঞ্চের ইতিহাস একত্রিত করে।
   * যদি কোনো কনফ্লিক্ট থাকে, তাহলে আপনাকে ম্যানুয়ালি কনফ্লিক্ট সলভ করতে হবে এবং তারপর মার্জ কমিট করতে হবে।

এই ধরনের মার্জ পদ্ধতিতে, আপনার ব্রাঞ্চের ইতিহাসে মার্জ কমিট দেখা যাবে, যা দেখায় কখন এবং কোথায় আপনার লোকাল পরিবর্তন এবং রিমোট পরিবর্তন একত্রিত হয়েছে।
## উদাহরণ:
  * ধরা যাক, আপনি একটি ফিচার ব্রাঞ্চে কাজ করছেন এবং আপনার কমিট আছে। একই সময়, রিমোট ব্রাঞ্চে অন্য কেউ পরিবর্তন করেছে। আপনি যখন git pull করবেন (যেখানে pull.rebase false কনফিগার করা আছে), তখন Git এই দুটি ব্রাঞ্চকে মার্জ   
  করবে, এবং মার্জ কমিট তৈরি হবে, যা ইতিহাসে দেখাবে যে আপনার কাজ এবং অন্যের কাজ একত্রিত হয়েছে।

### git config pull.rebase true
* যখন আপনি git config pull.rebase true ব্যবহার করেন, তখন git pull করার সময় Git রিবেস (rebase) প্রক্রিয়া অনুসরণ করবে। এর মানে হলো, যদি আপনার লোকাল ব্রাঞ্চে কিছু পরিবর্তন থাকে এবং রিমোট ব্রাঞ্চেও কিছু পরিবর্তন থাকে, তখন Git আপনার লোকাল কমিটগুলোকে রিমোট ব্রাঞ্চের উপরে স্থানান্তর (reapply) করবে, যাতে ইতিহাসটি লিনিয়ার (linear) থাকে এবং কোনো মার্জ কমিট তৈরি না হয়।

## বিস্তারিত:
 * Rebase প্রক্রিয়ায়, Git প্রথমে রিমোট ব্রাঞ্চের সমস্ত পরিবর্তন আপনার লোকাল ব্রাঞ্চে নিয়ে আসবে এবং তারপর আপনার লোকাল ব্রাঞ্চের (যেসব কমিট আপনি করেছেন) পরিবর্তনগুলোকে রিমোট ব্রাঞ্চের উপরে পুনরায় প্রয়োগ (reapply) করবে।
 * এর ফলে, ইতিহাস হবে একত্রিত (linear) এবং কোনো মার্জ কমিট তৈরি হবে না।
 * তবে, এটি আপনার কমিট ইতিহাসকে পুনরায় লেখা (rewrite) করে, অর্থাৎ আপনার লোকাল ব্রাঞ্চের কমিটগুলো নতুনভাবে পুনঃসংগ্রহ হয়, যা অন্যদের কাছে "নতুন" কমিট হিসেবে দেখা যেতে পারে।
   
## উদাহরণ:
ধরা যাক, আপনার লোকাল ব্রাঞ্চে দুটি কমিট আছে, এবং রিমোট ব্রাঞ্চে কিছু পরিবর্তন এসেছে। আপনি যখন git pull করবেন, Git:

 * প্রথমে রিমোট ব্রাঞ্চের সমস্ত পরিবর্তনগুলো আপনার লোকাল ব্রাঞ্চে নিয়ে আসবে।
 * এরপর আপনার লোকাল কমিটগুলোকে রিমোট ব্রাঞ্চের উপর পুনরায় প্রয়োগ করবে (reapply), যেন তারা রিমোটের উপরে থাকে।
 * এই প্রক্রিয়ায়, কোনো মার্জ কমিট তৈরি হবে না, এবং আপনার ব্রাঞ্চের ইতিহাস হবে সোজা (linear), যেমন আপনার কাজ রিমোটে সরাসরি যুক্ত হয়েছে।

### git config pull.ff only
  * যখন আপনি git config pull.ff only ব্যবহার করেন, তখন Git ফাস্ট-ফরওয়ার্ড (Fast-Forward) পদ্ধতি অনুসরণ করবে শুধুমাত্র যদি আপনার লোকাল ব্রাঞ্চ রিমোট ব্রাঞ্চের সাথে সিঙ্কড থাকে এবং কোনো ডাইভার্জেন্স না থাকে। এর মানে হলো,    আপনার   লোকাল ব্রাঞ্চে যদি কোনো পরিবর্তন না থাকে এবং আপনি রিমোট ব্রাঞ্চের পরিবর্তনগুলোর সাথে সিঙ্ক করতে চান, তবে Git শুধুমাত্র ফাস্ট-ফরওয়ার্ড মুডে কাজ করবে।
  git config pull.ff only ব্যবহার করলে, Git ফাস্ট-ফরওয়ার্ড পদ্ধতিতে কাজ করবে,অর্থাৎ শুধুমাত্র তখনই পুল করবে যখন আপনার লোকাল ব্রাঞ্চ রিমোট ব্রাঞ্চের পিছনে থাকে এবং কোনো ডাইভার্জেন্স (ভিন্নতা) না থাকে। এতে কোনো মার্জ কমিট   
  তৈরি হবে না, এবং ইতিহাস থাকবে সোজা ও পরিষ্কার।

## বিস্তারিত:
  * Fast-Forward ঘটে যখন আপনার লোকাল ব্রাঞ্চ রিমোট ব্রাঞ্চের পিছনে থাকে (অর্থাৎ, রিমোট ব্রাঞ্চে নতুন কমিট আছে, কিন্তু আপনার লোকাল ব্রাঞ্চে কোনো নতুন কাজ হয়নি)।
  * যদি আপনার লোকাল ব্রাঞ্চে কোনো পরিবর্তন থাকে এবং রিমোট ব্রাঞ্চে নতুন কমিট থাকে, তবে Git পুল করবে না, কারণ ফাস্ট-ফরওয়ার্ড সম্ভব নয়।
  * ফাস্ট-ফরওয়ার্ড পদ্ধতিতে, Git লোকাল ব্রাঞ্চের পয়েন্টারকে সরাসরি রিমোট ব্রাঞ্চের অবস্থানে এডভান্স করে দেয়, এবং কোনো মার্জ কমিট তৈরি হয় না।
    
## উদাহরণ:
ধরা যাক, আপনার লোকাল ব্রাঞ্চে কোনো নতুন কমিট নেই এবং রিমোট ব্রাঞ্চে নতুন দুটি কমিট এসেছে। আপনি যখন git pull করবেন:
 * Git ফাস্ট-ফরওয়ার্ড করবে এবং লোকাল ব্রাঞ্চের পয়েন্টারকে সরাসরি রিমোট ব্রাঞ্চের বর্তমান অবস্থানে নিয়ে যাবে।
 * এতে কোনো মার্জ কমিট তৈরি হবে না, এবং ইতিহাস হবে লিনিয়ার।
   
তবে, যদি আপনার লোকাল ব্রাঞ্চে কিছু কমিট থাকে এবং রিমোট ব্রাঞ্চেও কিছু কমিট থাকে, তাহলে Git পুল করতে অস্বীকৃতি জানাবে, কারণ ফাস্ট-ফরওয়ার্ড সম্ভব নয়।

### git reset --hard HEAD
* যখন আপনি git reset --hard HEAD কমান্ডটি ব্যবহার করবেন, তখন:
* আপনার সর্বশেষ কমিট (HEAD) এর অবস্থানে আপনার ব্রাঞ্চ ফিরে যাবে।
* আপনার সব অপ্রকাশিত পরিবর্তন (যেমন নতুন ফাইল তৈরি, কোডের পরিবর্তন, অথবা যে কোনো স্টেজড বা আনস্টেজড পরিবর্তন) মুছে যাবে।
* এটি শুধুমাত্র আপনার working directory এবং staging area (ইন্ডেক্স) এর পরিবর্তন মুছে ফেলবে, কোনো ফাইল বা কমিট হারাবে না, তবে আপনি যেগুলো স্টেজ বা কমিট করেননি, সেগুলো চিরকাল হারিয়ে যাবে।
  
## উদাহরণ:
* ধরা যাক, আপনি কিছু নতুন কোড লিখেছেন, কিছু ফাইল তৈরি করেছেন, কিন্তু সেই পরিবর্তনগুলো কমিট করেননি। এখন, আপনি যদি git reset --hard HEAD কমান্ডটি চালান, তাহলে:

* আপনার working directory (যেখানে আপনি ফাইল তৈরি করেছেন বা পরিবর্তন করেছেন) সেগুলো মুছে যাবে এবং ফাইল ও কোড আবার আগের অবস্থায় ফিরে যাবে যা আপনার শেষ কমিটে ছিল।
* আপনার staging area (যেখানে আপনি পরিবর্তন স্টেজ করেছেন)ও পরিষ্কার হয়ে যাবে, এবং কোনো পরিবর্তনই থাকবে না।
